\section{Design \& Architecture}\label{sec:Design}

\subsection{Development Process}\label{ssec:development}

A very early decision was made to adhere to Agile Software development
principles \cite{Fowl01a}
in developing this calculator
(to the extent possible given that the roles of Software Engineer, Scrum Manager
and Customer were all rolled into one).
In particular we stuck close to the YAGNI (``Ya Ain't Gonna Need It'') principle%
\footnote{More formally, ``Simplicity---the art of maximizing the amount
of work not done---is essential.''}
which requires us to only write software for a function
that is required at that time.
This does not prevent advanced design planning but does keep
the development focussed on immediate needs.
So initially the focus was on being able to use the calculator
to expand the UTP definition of an atomic action.
Once that was working, then the focus shifted to additional code to
support the calculation of the sequential composition of two atomic actions,
and so on.
For example, the feature to take a final calculation and output it to a file
was only developed when this paper was being written,
because there was no need for it until this point.

\subsection{Software Architecture}\label{ssec:architecture}

All the code described here is available online as a git repo
at
\\\url{https://andrewbutterfield@bitbucket.org/andrewbutterfield/utp-calculator.git}
as Literate Haskell Script%
\footnote{
Note, this paper is not itself a literate Haskell script
(you'll be relieved to know).
}
(\texttt{.lhs}) files in the \texttt{src} sub-directory.

Taking into account the repetitive nature of the calculations,
as mentioned at the end of \S\ref{ssec:plan},
and the need for shorthand notations we very rapidly converged
on four initial design decisions:
\begin{enumerate}
  \item No parsers! All calculation objects are written
  directly in Haskell.
  \item We would keep the expression and predicate datatype declarations
   very simple, with only equality being singled out.
  \item We would need to have a good way to pretty-print long predicates
    that made it easy to see their overall structure
  \item We would reply on a dictionary based system to enable default

\end{enumerate}
From our experience with the \UTP2 theorem-prover we also decided
the following regarding the calculation steps that would be supported:
\begin{itemize}
  \item
    We would not support full  propositional calculus
    or theories of numbers or sets.
    Instead we would support the use of hard-coded relevant laws,
    typically derived from  a handwritten proof.
  \item
    We would avoid, at all costs,
    any use of quantifiers or binding constructs.
  \item
    The calculator use interface would be very simple,
    supporting a few high level commands such as ``simplify''
    or ``reduce''.
    In particular,
    no facility would be provided for the user to identify
    the relevant sub-part of the current goal to which any operation
    should be applied.
\end{itemize}

We will now expand on some of the points above,
and in so doing expose some of the concrete architecture of the calculator code.

\subsection{Expressions and Predicates}\label{ssec:expr-pred}

In Fig. \ref{fig:expr-pred-types} we show the Haskell declarations
of the datatypes to represent both expressions and predicates.
Of course this means we are developing a deep embedding\cite{Gibbons:2014:FDS},
which is required in order to be able to do the kind of calculations we require.
\begin{figure}[tb]
\begin{code}
data Expr s
  = St s | B Bool | Z Int | Var String
  | App String [Expr s] | Sub (Expr s) (Substn s) | Undef

data Pred s
  = T | F | PVar String | Equal (Expr s) (Expr s) | Atm (Expr s)
  | Comp String [MPred s] | PSub (MPred s) (Substn s) | PUndef

type MPred s = (Marks, Pred s)
\end{code}
  \caption{Expression and Predicate Datatypes (\texttt{CalcTypes.lhs})}
  \label{fig:expr-pred-types}
\end{figure}
Both datatypes are parameterised on a generic state type \texttt{s},
which allows us to be able to handle different concrete types
of shared state with one piece of code.
Both types have basic values (\texttt{St},\texttt{B},\texttt{Z},\texttt{T},\texttt{F}),
variables (\texttt{Var},\texttt{PVar}),
generic composites (\texttt{App},\texttt{Comp}),
substitution (\texttt{Sub},\texttt{PSub})
and undefined values (\texttt{Undef},\texttt{PUndef}).
The predicate datatype has a way to embed a (boolean-valued)
expression to form an atomic predicate (\texttt{Atm}),
as well as an explicit form for atomic predicates that take
the form of an equality (\texttt{Equal}).
We give a specialised form for equality simply because
its use in laws is widespread and worth optimising.

Also important to point out is the fact that \texttt{Pred} is
defined in terms of \texttt{MPred}, which in turn is defined
in terms of \texttt{Pred}.
This is done to facilitate the association of markings (lists of integers)
with predicate constructs.
These markings are used to indicate which parts of a predicate
were changed at each calculation step.


\subsection{Pretty-Printing}\label{ssec:pp}

For the calculator output,
it is very important that it be readable,
as many of the predicates get very large,
particularly at intermediate points of the calculation.
For this reason, a lot of effort was put into the development
of both good pretty-printing,
and ways to highlight old and new parts of predicates as changes are made.
The key principle was to ensure that whenever a predicate
had to split over multiple lines,
that the breaks are always around the top-most operator or composition
symbol, with sub-components indented in.
An example of such pretty-printing in action is
{\small
\begin{verbatim}
    D(out)
 \/ (      ~ls(out)
        /\ (D(lg) \/ A(in,lg,a,in,lg,lg) \/ D(out) \/ A(lg,out,b,lg,out,out))
     ; W(D(lg) \/ A(in,lg,a,in,lg,lg) \/ D(out) \/ A(lg,out,b,lg,out,out)))
\end{verbatim}
}
The top-level structure of this is
\[D(out) \lor ( (\lnot ls(out) \land \dots) ; \W(\dots) )\]

The pretty printing support can be found in \texttt{PrettyPrint.lhs}.

\subsection{Dictionaries}\label{ssec:dict}

The abstract syntax is very simple,
and uses names as Haskell Strings to distinguish between
different composites.
So for example logical operators $\land$ and $\lor$
might be represented as \texttt{Comp "And"} and \texttt{Comp "Or"}
respectively.
We have a default way to pretty-print composites,
so that the predicate $\true \land \false$,
represented in Haskell by \texttt{Comp "And" [bT,bF]},
would render as \texttt{And(true,false)}.
However it would be nice to be able to render it as the usual
infix operator, giving \texttt{true /\BS\ false}.
In addition, we need some way to associate laws and definitions,
as appropriate, with composites.

The approach taken is to implement a dictionary that maps names
to entries that supply extra information.
The names can be those of expression or predicate composites,
or correspond to variables, and a few other features of note.
All of the main calculator functions are driven by this
dictionary,
and the correct definition of dictionary entries
is the primary way for users to set up calculations.

The standard approach is that the calculator
will seek information regarding some name that is
currently of interest.
It will perform a dictionary lookup which can result
in either failure, for which a suitable default action will be used,
or success, in which case the dictionary entry will supply
information to guide the required name-specific behaviour.


Also point out how this is a form of shallow-embedding.
So we can get the best (?) of both worlds\cite{Gibbons:2014:FDS}.

There are four kinds of dictionary entries,
one each for expressions and predicates,
one for laws of various kinds,
and one for alphabet handling.
We will discuss each kind in turn,
but leave examples of their use until Sect.\ref{sec:Theorising}.

One big win in using a functional language like Haskell,
in which functions are first class data values,
is that we can easily define datatypes that
contain function-valued components.
We make full use of this in three of the entry kinds discussed below.


\subsubsection{Expression Entries}~

\begin{code}
Entry s
  = ExprEntry 
    { ecansub :: [String]
    , eprint :: Dict s -> [Expr s] -> String
    , eval :: Dict s -> [Expr s] -> (String, Expr s)
    , isEqual :: Dict s -> [Expr s] -> [Expr s] -> Maybe Bool}
  | ...
\end{code}
Imagine that \texttt{App name args }is being processed
and that a dictionary lookup with key \texttt{name}
has returned an expression entry.
The entry contains four pieces of information:
\begin{description}
  \item[\texttt{ecansub}]
     is a list of variable names,
      over which it is safe to perform substitutions.
  \item[\texttt{eprint}]
    is a function that takes a dictionary as first argument,
    the argument-list \texttt{args} as its second argument
    and returns a string rendering of the expression.
    Currently we view expressions as atomic one-line texts
    for output purposes.
  \item[\texttt{eval}]
    takes similar arguments to \texttt{eprint},
    but returns a string/expression pair,
    that denotes a possible evaluation or simplification
    of the original expression.
    The string is empty if no change occurred,
    otherwise it is a short description of/name for the eval/simplify step.
  \item[\texttt{isEqual}]
    has a dictionary argument, followed by two sub-expression lists.
    it tests for (in)equality, returning \texttt{Just True} or \texttt{Just False}
    if it can establish (in)equality,
    and \texttt{Nothing} if unable to give a definitive answer.
\end{description}
The dictionary argument supplied to the three functions
is always the same as the dictionary in which the entry was found.

To understand the need for \texttt{ecansub},
consider the following shorthand definition for an expression:
\[
  D(L) \defs L \subseteq ls
\]
in a context where we know that $L$ is a set expression defined
only over variables $g$, $in$ and $out$.
Now, consider the following instance, with a substitution,
and two attempts to calculate a full expansion:
\begin{eqnarray*}
   & D(\setof{out})[\setof{\ell_1},\ell_2/ls,out] &
\\ (\setof{out \subseteq ls})[\setof{\ell_1},\ell_2/ls,out]=
 && = D(\setof{\ell_2})
\\ \setof{\ell_2} \subseteq \setof{\ell_1}=
 && = \setof{\ell_2} \subseteq ls
\end{eqnarray*}
The lefthand calculation is correct, the righthand is not.
The substitution refers to variables (e.g. $ls$)
that are hidden when the $D$ shorthand is used.
The \texttt{ecansub} entry lists the variables for which substitution
is safe with the expression as-is.
With the definition above, the value of this entry
 should be \texttt{["g","in","out"]}.
Given that entry, the calculator would simplify (correctly) as follows:
\[
  D(\setof{\ell_2})[\setof{\ell_1}/ls]
\]
The righthand side of the definition is what should be returned
by the \texttt{eval} component.
If we want to state that any substitution is safe,
then we use the ``wildcard'' form: \texttt{["*"]}.


\subsubsection{Predicate Entries}~

\begin{code}
Entry s
  = ...
  | PredEntry 
    { pcansub :: [String]
    , pprint :: Dict s -> MarkStyle -> Int -> [MPred s] -> PP
    , alfa :: [String]
    , pdefn :: Rewrite s
    , prsimp :: Rewrite s }
type Rewrite s = Dict s -> [MPred s] -> (String, Pred s)
\end{code}
The predicate entry associated with Comp name pargs
has five fields:
\begin{description}
  \item[\texttt{pcansub}]
    does for predicates what \texttt{ecansub} does for expressions.
  \item[\texttt{pprint}]
    is similar to \texttt{eprint} except it has two extra arguments,
    used to help with special renderings for predicates marked as changed,
    and precedence levels for managing bracketing.
    We do pretty-printing tricks such as indenting and adding line-breaks
    at the predicate level.
  \item[\texttt{alfa}]
    is used to identify the alphabet of the predicate.
  \item[\texttt{pdefn}]
    is a function invoked when \texttt{name} has a definition,
    and we want to expand it.
  \item[\texttt{prsimp}]
    is called by the simplifier when processing \texttt{name}.
\end{description}
Both \texttt{pdefn} and \texttt{prsimp} take a dictionary argument
and list of sub-component (marked)predicates,
returning a string/predicate pair,
interpreted in a manner similar to \texttt{eval} above.

\subsubsection{Law Entries}~

\begin{code}
Entry s
  = ...
  | LawEntry  { reduce :: [DictRWFun s]
              , creduce :: [CDictRWFun s]
              , unroll :: [String -> DictRWFun s] }
\end{code}
Law entries are currently only associated with one key,
namely the string \texttt{"laws"},
which is what the calculator uses to find such entries.
There are three parts,
each consisting of lists of functions.
These lists are intended to be be applied in order to the
``current predicate'', until either one succeeds,
or none do.
All the functions take a dictionary
and (marked) predicate as arguments,
and return either
an single-outcome indicator (\texttt{reduce},\texttt{unroll}):
\begin{code}
type DictRWFun s = Dict s -> RWFun sdata
type RWFun s = MPred s -> RWResult s
type RWResult s = (String, MPred s)
\end{code}
or a conditional  multiple-outcome result (\texttt{creduce}).
\begin{code}
type CDictRWFun s = Dict s -> CRWFun s
type CRWFun s = MPred s -> CRWResult s
type CRWResult s = (String, [(Pred s, MPred s)])
\end{code}
\begin{description}
  \item[\texttt{reduce}]
     is a list of reduction laws,
     to be tried out when a reduction step is invoked by the user.
  \item[\texttt{creduce}]
    is a list of conditional reduction laws,
    which have multiple outcomes dependent on a side-condition.
    Rather than try to resolve conditions automatically,
    we prefer to let the user choose the appropriate outcome.
  \item[\texttt{loop}]
    is a list of loop-unrolling functions.
    The extra string argument is to give the user finer control
    of how much unrolling is done, and how it is presented
    (see later).
\end{description}


\subsubsection{Alphabet Entries}~

\begin{code}
Entry s
  = ...
  | AlfEntry  { avars :: [String]}
\end{code}
Most simply put, an alphabet is simply a set of variables.
In any UTP theory we typically have well-defined alphabets,
often with particular subsets of interest,
such as all the ``before'' observations (undashed variables),
or ``after'' observations (dashed variables).
We give these subsets standardised names,
and use the dictionary to list the relevant variables.


\subsection{The Calculator REPL}

The way the calculator is designed to be used is
that a function implementing a calculator Read-Execute-Print-Loop (REPL)
is given a dictionary and starting predicate as inputs.
It then offers the user the opportunity to invoke various
commands to perform calculation steps.
The user can then indicate when they are finished,
at which point the calculator function returns
a data-structure that logs the complete calculation outcome.
This is a triple consisting of the final predicate,
a list of the steps, each with a justification string,
and the dictionary that was used.
\begin{code}
type CalcLog s = (MPred s, [RWResult s], Dict s)
\end{code}

Calculator commands include an ability to undo previous steps ('\texttt{u}'),
request help ('\texttt{?}'),
and to signal an exit from the calculator ('\texttt{x}').
However,
of most interest are the five calculation commands.
The first is a global simplify command ('s'),
that scans the entire predicate from the bottom-up
looking for simplifiers for each composite and applying them.
Simplifiers are captured as \texttt{eval} or \texttt{prsimp} components
in dictionary entries.

The other four commands work by searching top-down, depth-first for
the first sub-component for which the relevant dictionary calculator
function returns a changed result.
Here is where we have a reduced degree of control,
which simplifies the REPL dramatically,
but turns out to be strikingly effective in practise.
This is because these kinds of semantic ``smoke-test'' calculations
tend to go in phases: expand all definitions; simplify; reduce; simplify;
perhaps unroll a loop a bit; etc...
\begin{description}
  \item[Defn. Expand ('\texttt{d}')]
    Find the first predicate changed by applying its
     \texttt{pdefn} dictionary entry, which should unfold its definition.
  \item[Law Reduce ('\texttt{r}')]
    Find the first predicate transformed by a function
    in the \texttt{reduce} list of the \texttt{LawEntry} indexed
     by the string \texttt{"laws"}.
     This function captures an equational law,
     that is only applied in a left to right direction.
  \item[Loop Unroll ('\texttt{l}')]
    Find the first predicate transformed by a function
    in the \texttt{unroll} list of the \texttt{LawEntry} indexed
     by the string \texttt{"laws"}.
    The remainder of the command string after the initial '\texttt{l}'
    is passed to the function to control the nature and degree
    of unrolling. How this string is interpreted is entirely
    up to the user---see Sect. \ref{sec:Theorising} for an example.
  \item[Conditional Reduce ('\texttt{c}')]
    Find the first predicate transformed by a function
    in the \texttt{creduce} list of the \texttt{LawEntry} indexed
     by the string \texttt{"laws"}.
     This function captures an equational law with a side condition,
    which returns a list of alternatives,
    each alternative being a side-condition predicate
    paired with a result.
    These are presented to the user,
    who then selects which outcome is appropriate.
    In effect the user has to look at each condition
    and select the one (if any) that evaluates to true.
    This is done to prevent the calculator from having
    to embody predicate simplifiers ``modulo various expression theories''.
\end{description}

