\section{Design \& Architecture}\label{sec:Design}

\subsection{Development Process}\label{ssec:development}

A very early decision was made to adhere to Agile Software development
principles \cite{Fowl01a}
in developing this calculator
(to the extent possible given that the roles of Software Engineer, Scrum Manager
and Customer were all rolled into one).
In particular we stuck close to the YAGNI (``Ya Ain't Gonna Need It'') principle%
\footnote{More formally, ``Simplicity---the art of maximizing the amount
of work not done---is essential.''}
which requires us to only write software for a function
that is required at that time.
This does not prevent advanced design planning but does keep
the development focussed on immediate needs.
So initially the focus was on being able to use the calculator
to expand the UTP definition of an atomic action.
Once that was working, then the focus shifted to additional code to
support the calculation of the sequential composition of two atomic actions,
and so on.
For example, the feature to take a final calculation and output it to a file
was only developed when this paper was being written,
because there was no need for it until this point.

\subsection{Software Architecture}\label{ssec:architecture}

All the code described here is available online as a git repo
at
\\\url{https://andrewbutterfield@bitbucket.org/andrewbutterfield/utp-calculator.git}
as Literate Haskell Script%
\footnote{
Note, this paper is not itself a literate Haskell script
(you'll be relieved to know).
}
(\texttt{.lhs}) files in the \texttt{src} sub-directory.

Taking into account the repetitive nature of the calculations,
as mentioned at the end of \S\ref{ssec:plan},
and the need for shorthand notations we very rapidly converged
on four initial design decisions:
\begin{enumerate}
  \item No parsers! All calculation objects are written
  directly in Haskell.
  \item We would keep the expression and predicate datatype declarations
   very simple, with only equality being singled out.
  \item We would need to have a good way to pretty-print long predicates
    that made it easy to see their overall structure
  \item We would reply on a dictionary based system to enable default

\end{enumerate}
From our experience with the \UTP2 theorem-prover we also decided
the following regarding the calculation steps that would be supported:
\begin{itemize}
  \item
    We would not support full  propositional calculus
    or theories of numbers or sets.
    Instead we would support the use of hard-coded relevant laws,
    typically derived from  a handwritten proof.
  \item
    We would avoid, at all costs,
    any use of quantifiers or binding constructs.
  \item
    The calculator use interface would be very simple,
    supporting a few high level commands such as ``simplify''
    or ``reduce''.
    In particular,
    no facility would be provided for the user to identify
    the relevant sub-part of the current goal to which any operation
    should be applied.
\end{itemize}

We will now expand on some of the points above,
and in so doing expose some of the concrete architecture of the calculator code.

\subsection{Expressions and Predicates}\label{ssec:expr-pred}

In Fig. \ref{fig:expr-pred-types} we show the Haskell declarations
of the datatypes to represent both expressions and predicates.
Of course this means we are developing a deep embedding\cite{Gibbons:2014:FDS},
which is required in order to be able to do the kind of calculations we require.
\begin{figure}[tb]
\begin{verbatim}
data Expr s
  = St s | B Bool | Z Int | Var String
  | App String [Expr s] | Sub (Expr s) (Substn s) | Undef

data Pred s
  = T | F | PVar String | Equal (Expr s) (Expr s) | Atm (Expr s)
  | Comp String [MPred s] | PSub (MPred s) (Substn s) | PUndef

type MPred s = (Marks, Pred s)
\end{verbatim}
  \caption{Expression and Predicate Datatypes (\texttt{CalcTypes.lhs})}
  \label{fig:expr-pred-types}
\end{figure}
Both datatypes are parameterised on a generic state type \texttt{s},
which allows us to be able to handle different concrete types
of shared state with one piece of code.
Both types have basic values (\texttt{St},\texttt{B},\texttt{Z},\texttt{T},\texttt{F}),
variables (\texttt{Var},\texttt{PVar}),
generic composites (\texttt{App},\texttt{Comp}),
substitution (\texttt{Sub},\texttt{PSub})
and undefined values (\texttt{Undef},\texttt{PUndef}).
The predicate datatype has a way to embed a (boolean-valued)
expression to form an atomic predicate (\texttt{Atm}),
as well as an explicit form for atomic predicates that take
the form of an equality (\texttt{Equal}).
We give a specialised form for equality simply because
its use in laws is widespread and worth optimising.

Also important to point out is the fact that \texttt{Pred} is
defined in terms of \texttt{MPred}, which in turn is defined
in terms of \texttt{Pred}.
This is done to facilitate the association of markings (lists of integers)
with predicate constructs.
These markings are used to indicate which parts of a predicate
were changed at each calculation step.


\subsection{Pretty-Printing}\label{ssec:pp}

For the calculator output,
it is very important that it be readable,
as many of the predicates get very large,
particularly at intermediate points of the calculation.
For this reason, a lot of effort was put into the development
of both good pretty-printing,
and ways to highlight old and new parts of predicates as changes are made.
The key principle was to ensure that whenever a predicate
had to split over multiple lines,
that the breaks are always around the top-most operator or composition
symbol, with sub-components indented in.
An example of such pretty-printing in action is
{\small
\begin{verbatim}
    D(out)
 \/ (      ~ls(out)
        /\ (D(lg) \/ A(in,lg,a,in,lg,lg) \/ D(out) \/ A(lg,out,b,lg,out,out))
     ; W(D(lg) \/ A(in,lg,a,in,lg,lg) \/ D(out) \/ A(lg,out,b,lg,out,out)))
\end{verbatim}
}
The top-level structure of this is
\[D(out) \lor ( (\lnot ls(out) \land \dots) ; \W(\dots) )\]

The pretty printing support can be found in \texttt{PrettyPrint.lhs}.

\subsection{Dictionaries}\label{ssec:dict}

The abstract syntax is very simple,
and uses names as Haskell Strings to distinguish between
different composites.
So for example logical operators $\land$ and $\lor$
might be represented as \texttt{Comp "And"} and \texttt{Comp "Or"}
respectively.
We have a default way to pretty-print composites,
to that the predicate $\true \land \false$,
represented in Haskell by \texttt{Comp "And" [bT,bF]},
would render as \texttt{And(true,false)}.
However it would be nice to be able to render it as the usual
infix operator, giving \texttt{true /\BS\ false}.
In addition, we need some way to associate laws and definitions,
as appropriate, with composites.

The approach taken is to implement a dictionary that maps names
to entries that supply extra information.
The names can be those of expression or predicate composites,
or correspond to variables, and a few other features of note.
All of the main calculator functions are driven by this
dictionary,
and the correct definition of dictionary entries
is the primary way for users to set up calculations.
There are four kinds of dictionary entries,
one each for expressions and predicates,
one for laws of various kinds,
and one for alphabet handling.
We will discuss each kind in turn.

\subsubsection{Expression Entries}

\begin{verbatim}
Entry s
  = ExprEntry { ecansub :: [String]
              , eprint :: Dict s -> [Expr s] -> String
              , eval :: Dict s -> [Expr s] -> (String, Expr s)
              , isEqual :: Dict s -> [Expr s] -> [Expr s] -> Maybe Bool }
  | ...
\end{verbatim}

\subsubsection{Predicate Entries}

\begin{verbatim}
Entry s
  = ...
  | PredEntry { pcansub :: [String]
              , pprint :: Dict s -> MarkStyle -> Int -> [MPred s] -> PP
              , alfa :: [String]
              , pdefn :: Rewrite s
              , prsimp :: Rewrite s }
type Rewrite s = Dict s -> [MPred s] -> (String, Pred s)
\end{verbatim}


\subsubsection{Law Entries}

\begin{verbatim}
Entry s
  = ...
  | LawEntry  { reduce :: [DictRWFun s]
              , creduce :: [CDictRWFun s]
              , unroll :: [String -> DictRWFun s] }
type DictRWFun s = Dict s -> RWFun sdata
type RWFun s = MPred s -> RWResult s
type RWResult s = (String, MPred s)
\end{verbatim}


\subsubsection{Alphabet Entries}

\begin{verbatim}
Entry s
  = ...
  | AlfEntry  { avars :: [String]}
\end{verbatim}


One big win in using a functional language like Haskell,
in which functions are first class data values,
is that we can easily define datatypes that
contain function-valued components.

Also point out how this is a form of shallow-embedding.
So we can get the best (?) of both worlds\cite{Gibbons:2014:FDS}.

Show how the $ls(L)$ shorthand gets encoded,
and a predicate definition.

See also \texttt{CalcAlphabets.lhs}

\subsection{Coding Laws}\label{ssec:coding-laws}

Explain the \texttt{Rewrite}/\texttt{RWResult} distinction
and give an example of a \texttt{DictRWFun}.

\subsection{No Quantifiers}\label{ssec:no-quant}

    They bring a world of pain with them,
    and as it turns out, are not required
    for the kinds of calculations we wish to do.
    Handwritten proofs of laws involving concepts
    defined using quantifier and binders
    are required to validate the laws,
    but these are easy to do---the pain is automating these proofs,
    not doing them by hand.

    Substitutability

\subsection{No Targetting}\label{ssec:no-target}

First-come, first-served.

\subsection{Dictionary Libraries}

explain how dictionaries are managed and constructed,
and describe the ``builtin'' dictionaries (a.k.a. \texttt{StdXXX})
