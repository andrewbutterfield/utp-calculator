\section{Related Work}\label{sec:Related}

There are lots of tools for assisting with the kinds of
calculations we are trying to perform,
ranging from calculators
\cite{Bird14},
through rewrite/transformation
systems
(Unfold/Fold\cite{BurstallAndDarlington77},
CIP-S\cite{DBLP:books/sp/BauerEH87},
ZAP\cite{Feather:1982:SAP:357153.357154},
KIDS\cite{Smith91},
Stratego\cite{conf/rta/Visser01},
ASF+DSF\cite{VanDenBrand:2002:CLD}
Maude\cite{conf/rta/ClavelDELMMT03}
HATS\cite{conf/gttse/WinterB06})
to full-blown theorem provers
(Isabelle/HOL\cite{books/sp/NipkowPW02},
CoQ\cite{bk:Coq'Art:04},
PVS\cite{conf/fmcad/Shankar96})
including those that support equational reasoning
(Isabelle/ISAR\cite{man:Isabelle:Isar:Wenzel:10}).

Most of the above have a considerable body of work behind,
both in terms of theory and tool development,
and provide very comprehensive coverage of their problem domain,
be it rewriting, program transformation or theorem proving.
However many are tied to specific languages,
or have limited ability to allow the user to customise the target language.
In particular,
it is not in clear any of them,
how to achieve the ability to do rapid calculation
with a high degree of ease in proof-reading its
output.

In addition to our own work on theorem proving for UTP \cite{conf/utp/Butterfield10},
there is also work on embedding UTP into Isabelle/HOL\cite{DBLP:conf/utp/FosterZW14}.

Within the UTP community,
there has been considerable work using Proof{\-}Power-Z
such as deep embedding into Z of an imperative language whose semantics
were given using UTP \cite{conf/utp/NukaW06}and
 re-working the mechanisation of UTP in order to better support
the hierarchical nature of UTP theory building \cite{journals/entcs/ZeydaC09}.
Some support for Z-like theories from UTP (such as Circus)
can be found as extensions implemented in the Community Z Tools project
\cite{conf/zum/MalikU05}.

Whilst all of good pedigree, CoQ, Isabelle/HOL, ProofPower-Z and PVS
all have in common that they work best when used in the manner
for which they were designed%
---in none of these cases does this manner match the way
we wish to work in UTP, as described in the introduction.



\subsection{The decision}

We briefly considered using the \UTP2 theorem prover
\cite{DBLP:conf/utp/Butterfield10,DBLP:conf/utp/Butterfield12},
but it would have required a lot of setup effort,
and it is currently not in an ideal state%
\footnote{The issue has to do with difficulties installing
the relevant software libraries
on more recent versions of Haskell.}
.
However, as part of our work on the formal semantics of PML,
we had developed a parser and some initial analysis tools
in Haskell\cite{Haskell2010},
and this software contained abstract syntax and support
for general predicates.
It became really obvious that this could be quickly adapted,
to mechanise the checking calculations, that were being performed
during each attempt.
In particular,
the key inspiration was the observation,
over all of those calculation attempts (five in all!),
that the pattern of each calculation was very uniform and similar.
So a decision was taken to construct the calculator described in this paper.
