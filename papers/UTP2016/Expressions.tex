\section{Expressions}\label{sec:Expressions}

In Fig. \ref{fig:expr-types} we show the Haskell declarations
of the datatypes used to represent expressions and substitution.
\begin{figure}[tb]
\begin{verbatim}
data Expr s
  = St s | B Bool | Z Int | Var String
  | App String [Expr s] | Sub (Expr s) (Substn s) | Undef
  deriving (Eq, Ord, Show)

type Substn s = [(String,Expr s)]
\end{verbatim}
  \caption{Expression and Substitution Datatypes (\texttt{CalcTypes.lhs})}
  \label{fig:expr-types}
\end{figure}
Both types are parameterised on a generic state type \texttt{s},
which allows us to be able to reason independently of any particular type, or with a specific concrete type in mind,
all with one piece of code.
We provide booleans (\texttt{B}),
integers (\texttt{Z}),
values of the parameter type (\texttt{St}),
named function application(\texttt{App})
and a substitution (\texttt{Sub}), which pairs an expression
with a substitution (\texttt{Substn}) which is a list of variable/expression pairs, each denoting the replacement of all free
occurrences of the variable by the corresponding expression.
The \texttt{deriving} clause for \texttt{Expr} enables the Haskell default notions
of equality, ordering and display for the type.
Functions are identifer by a name (\texttt{String})
and missing are any binding constructs, such as lambda expressions,
or the ability to curry functions.

\subsection{Set Expressions}

We shall explore the use of the \texttt{Expr}  datatype
by indicating how the notions of sets and some basic operators
could be defined with the calculator.
We shall represent sets as instances of \texttt{App} with the name ``set'',
and the subset relation as an \texttt{App} with name ``subset'',
so the set $\setof{1,2}$ would be represented by
\verb$App "set" [Z 1,Z 2]$,
and the predicate $S \subseteq T$ by
\verb$App "subset" [Var "S",Var "T"]$.
In practice, we would define constructor functions to build
these:
\begin{code}
set es = App "set" es
subset s1 s2 = App "subset" [s1,s2]
\end{code}
There is a standard interface for defining expression simplifiers:
define a function with the following type:
\begin{verbatim}
Dict s -> [Expr s] -> (String, Expr s)
\end{verbatim}
The first argument, of type \texttt{Dict},
is the dictionary currently in use.
The second argument is the list of sub-expression of
the \texttt{App} construct for which the simplifier is intended.
The result is a pair consisting of a string and an expression.
If the simplification succeeds, then the string is non-empty
and gives some indication
of what was simplified,
while the expression component is the simplified result.
If the simplification has no effect, then the string is empty,
and the expression return is not defined.

The following code defines a simplifier for subset
(with not quite the right type):
\begin{code}
dosubset d es1 es2 -- is es1 a subset of es2 ?
  | null es1lesses2  =  ( "subset", B True )
  | all (isGround d) (es1lesses2 ++ es2)
                     =  ( "subset", B False )
  | otherwise        =  none
  where
    es1lesses2 = es1 \\ es2
\end{code}
It is basically a Haskell function definition with three alternatives,
tested in order.

The second test sees if all elements remaining are ``ground'',
i.e. do not contain any dynamic observation variables.
Static parameter variables are considered ground,
for reasons beyond the scope of this paper.
The function \texttt{isGround} takes a dictionary,
and an expression, and checks to see if the expression is ground.
It uses the dictionary to get information about the status
of any variables it may find, by using the \verb$"Stc"$ key
(Fig. \ref{fig:rsvd-names}) to identify the static variables.

For the simplifier, we need a list of expressions,
rather than two as arguments, after the dictionary argument.
We use \texttt{evalSubset} to pattern match on the expression list
associated with an instance of subset,
and then to call \texttt{dosubset} as appropriate.
We expect the expression list to be of length 2,
each entry denoting a set.
\begin{code}
evalSubset d [App "set" es1,App "set" es2] = dosubset d es1 es2
evalSubset _ _ = none
\end{code}
The first line above matches the case when both sets are enumerations.
The last line is a catch-all with wildcard patterns that matches
any other case, returning none.

Note that there is no notion of general type-checking
in the calculator---it would introduce far too much complexity,
with very little gain,
for the type of work for which this calculator has been designed.

\subsection{Rendering Expressions}

The UTCP theory definitions and calculations
involve a lot of reasoning about sets,
leading to quite complicated expressions.
To avoid long set expressions a number of shorthand notations are desirable,
so that a singleton set $\setof x$ is rendered as $x$
and the very common idiom $S \subseteq ls$
is rendered as $ls(S)$,
so that for example, $ls(in)$ is short for $\setof{in} \subseteq ls$.
We also introduce $S \ominus (T,U)$ as shorthand for $(S \setminus T) \cup U$
(from\cite{DBLP:conf/icfem/WoodcockH02}).
These shrinks the expressions to a much more readable form/


When rendering expressions,
if an \texttt{App} construct is found, then its name
is looked up in the dictionary.
If an \texttt{ExprEntry} is not found, then the default rendering is used,
in which \verb$App "f" [e1,e2,..,en]$
is converted into \verb$f(e1,e2,..,en)$.
Otherwise, a function in that entry,
of type \verb$Dict s -> [Expr s] -> String$
is used to render the construct.

As far as expressions are concerned,
they become strings, and so are viewed as atomic
by the predicate pretty-printer (see Sect. \ref{sec:Predicates}.
So far there has been no real need to extend full layout control
down into expressions,
mainly because of the shorthands that have been defined
that keep expressions short.

So, we could show singleton sets without enclosing braces
by defining:
\begin{code}
showSet d [elm] = edshow d elm      -- drop {,} from singleton
showSet d elms = "{" ++ dlshow d "," elms ++ "}"
\end{code}
Here \texttt{dlshow} (dictionary-list-show) displays the expressions
in its 3rd argument separated by the 2nd,
using its first dictionary argument.

Similar code can be written for the subset application.
\begin{code}
showSubSet d [App "set" elms,App "set" [set]]
 = edshow d set ++ "(" ++ dlshow d "," elms ++ ")"
showSubSet d [App "set" elms,set]
 = edshow d set ++ "(" ++ dlshow d "," elms ++ ")"
showSubSet d [e,set]
 = edshow d set ++ "(" ++ edshow d e ++ ")"
\end{code}
Here \texttt{edshow} uses a dictionary to render an expression as a string.

\subsection{Expression Equality}

In contrast to the way that the subset predicate
is captured as an expression above,
the notion of expression equality is hardwired in,
as part of the predicate abstract syntax (see Sect\ref{sec:Predicates}).
The simplifier will look at the two expression
arguments of that construct,
and if they are both instances of \texttt{App} with the same name,
will do a dictionary lookup, to see if there
is an entry, from
which an equality checking function can be obtained.
This has the following signature:
\begin{verbatim}
Dict s -> [Expr s] -> [Expr s] -> Maybe Bool
\end{verbatim}
Such a function takes a dictionary and the two expression
lists from the two \texttt{App} instances
and either returns Nothing, if it cannot establish

Suitable code for \verb$"set"$ is the following
\begin{code}
eqSet d es1 es2
 = let ns1 = nub $ sort $ es1
       ns2 = nub $ sort $ es2
   in if all (isGround d) (ns1++ns2)
      then Just (ns1==ns2)
      else Nothing
\end{code}
The standard function nub removes duplicates,
and so if both lists are ground we just do an equality comparison
and return it. Otherwise, we return nothing.


Similar tricks are used to code a very compact rendering
of a mechanism that involves unique label generators
that can also be split, so that an expression like
\[
 \pi_2(new(\pi_1(new(\pi_1(split(\pi_1(new(g))))))))
\]
can be displayed as $\ell_{g:1:}$, or,
within the calculator, as \texttt{lg:1:} .


\subsection{The Expression Entry}~

The dictionary entry for expressions has the following form:
\begin{verbatim}
Entry s
  = ExprEntry
    { ecansub :: [String]
    , eprint :: Dict s -> [Expr s] -> String
    , eval :: Dict s -> [Expr s] -> (String, Expr s)
    , isEqual :: Dict s -> [Expr s] -> [Expr s] -> Maybe Bool}
  | ...
\end{verbatim}
One big win in using a functional language like Haskell,
in which functions are first class data values,
is that we can easily define datatypes that
contain function-valued components.
We make full use of this in three of the entry kinds,
for expressions, predicates and laws.

The \texttt{eprint}, \texttt{eval} and \texttt{isEqual} components correspond
to the various examples we have seen above.
The \texttt{ecansub} component
indicates those variables occurring in the \texttt{App} expression
list for which it is safe to replace in substitutions.

To understand the need for \texttt{ecansub},
consider the following shorthand definition for an expression:
\[
  D(L) \defs L \subseteq ls
\]
in a context where we know that $L$ is a set expression defined
only over variables $g$, $in$ and $out$.
Now, consider the following instance, with a substitution,
and two attempts to calculate a full expansion:
\[\begin{array}{l@{\qquad}l}
   D(\setof{out})[\setof{\ell_1},\ell_2/ls,out]
 & D(\setof{out})[\setof{\ell_1},\ell_2/ls,out]
\\ {} = (\setof{out} \subseteq ls)[\setof{\ell_1},\ell_2/ls,out]
 & {}= D(\setof{\ell_2})
\\ {} = \setof{\ell_2} \subseteq \setof{\ell_1}
 & {} = \setof{\ell_2} \subseteq ls
\end{array}\]
The lefthand calculation is correct, the righthand is not.
The substitution refers to variables (e.g. $ls$)
that are hidden when the $D$ shorthand is used.
The \texttt{ecansub} entry lists the variables for which substitution
is safe with the expression as-is.
With the definition above, the value of this entry
 should be \texttt{["g","in","out"]}.
Given that entry, the calculator would simplify (correctly) as follows:
\[
  D(\setof{\ell_2})[\setof{\ell_1}/ls]
\]
The righthand side of the definition is what should be returned
by the \texttt{eval} component.
If we want to state that any substitution is safe,
then we use the ``wildcard'' form: \texttt{["*"]}.

Given all of the above,
we can define dictionary entries for set and subset as
\begin{code}
setUTCPDict
 = makeDict
    [ ("set",(ExprEntry ["*"] showSet evalSet eqSet))
    , ("subset",(ExprEntry ["*"] showSubSet evalSubset noEq)) ]
\end{code}
Here \texttt{noEq} is a function that always returns \texttt{Nothing}.
