\section{Expressions}\label{sec:Expressions}

In this section we focus on how to specify the properties and
rendering of expressions of interest.

In Fig. \ref{fig:expr-types} we show the Haskell declarations
of the datatypes used to represent expressions and substitution.
\begin{figure}[tb]
\begin{verbatim}
data Expr s
  = St s | B Bool | Z Int | Var String
  | App String [Expr s] | Sub (Expr s) (Substn s) | Undef
  deriving (Eq, Ord, Show)
  
type Substn s = [(String,Expr s)]
\end{verbatim}
  \caption{Expression and Substitution Datatypes (\texttt{CalcTypes.lhs})}
  \label{fig:expr-types}
\end{figure}
Both types are parameterised on a generic state type \texttt{s},
which allows us to be able to reason independently of any particular type, or with a specific concrete type in mind,
all with one piece of code.
In expressions (\texttt{Expr}) we include booleans (\texttt{B}) and integers (\texttt{Z}) as basic types,
as well as values of the parameter type (\texttt{St}).
We then have the notion of the application (\texttt{App}) of a named function
to a list of expression arguments,
and a substitution (\texttt{Sub}), which pairs an expression
with a substitution (\texttt{Substn}) which is a list of variable/expression pairs, each denoting the replacement of all free
occurrences of the variable by the corresponding expression.
The \texttt{deriving} clause for \texttt{Expr} enables the Haskell default notions
of equality, ordering and display for the type.

The abstract expression syntax is very simple,
and uses names, as Haskell Strings, to distinguish between
different applications.
Missing are any binding constructs, such as lambda expressions,
or the ability to curry functions.

\subsection{Set Expressions}

We shall explore the use of the \texttt{Expr}  datatype
by indicating how the notions of sets and some basic operators
could be defined with the calculator.
We shall represent sets as instances of \texttt{App} with the name ``set'',
and the subset relation as an \texttt{App} with name ``subset'',
so the set $\setof{1,2}$ would be represented by 
\verb$App "set" [Z 1,Z 2]$, 
and the predicate $S \subseteq T$ by
\verb$App "subset" [Var "S",Var "T"]$.
In practice, we would define constructor functions to build
these:
\begin{code}
set es = App "set" es
subset s1 s2 = App "subset" [s1,s2]
\end{code}
We will want an equality test for sets,
but as equality is handled at the predicate level, we defer discussion until later.
However, it will be very useful to be able to simplify
uses of subset.
There is a standard interface for defining expression simplifiers:
define a function with the following type:
\begin{verbatim}
Dict s -> [Expr s] -> (String, Expr s)
\end{verbatim}
The first argument, of type \texttt{Dict}, 
is the dictionary currently in use,
which we describe in more detail later on.
The second argument is the list of sub-expression of
the \texttt{App} construct for which the simplifier is intended.
The result is a pair consisting of a string and an expression.
If the simplification succeeds, then the string is non-empty
and gives some indication
of what was simplified,
while the expression component is the simplified result.
If the simplification has no effect, then the string is empty,
and the expression return is not defined.

The following code defines a simplifier for subset
(with not quite the right type):
\begin{code}
dosubset d es1 es2 -- is es1 a subset of es2 ?
  | null es1lesses2  =  ( "subset", B True )
  | all (isGround d) (es1lesses2 ++ es2)
                     =  ( "subset", B False )
  | otherwise        =  none
  where
    es1lesses2 = es1 \\ es2
\end{code}
It is basically a Haskell function definition with three alternatives,
tested in order.

The first simply returns an expression denoting true 
if the result of subtracting the second list from the first
is empty---using the standard Haskell sequence difference operator (\verb$\\$).

The second test sees if all elements remaining are ``ground'',
i.e. do not contain any dynamic observation variables.
Static parameter variables are considered ground,
for reasons beyond the scope of this paper.
If the test succeeds, 
then we have leftover values, so we can conclude that \texttt{es1} is not a subset of \texttt{es2}.
The function \texttt{isGround} takes a dictionary,
and an expression, and checks to see if the expression is ground.
It uses the dictionary to get information about the status
of any variables it may find.

The 3rd clause (otherwise) means we have some different
variables in the sets, which might have the same values,
or might not, so we cannot conclude anything further.
We return the predefined value \texttt{none} which is defined to be 
\verb$("",Undef)$.

For the simplifier, we need a list of expressions,
rather than two as arguments, after the dictionary argument.
We use \texttt{evalSubset} to pattern match on the expression list
associated with an instance of subset,
and then to call \texttt{dosubset} as appropriate.
We expect the expression list to be of length 2,
each entry denoting a set.
\begin{code}
evalSubset d [App "set" es1,App "set" es2] = dosubset d es1 es2
evalSubset d [es1,App "set" es2] = dosubset d [es1] es2
evalSubset d [App "set" es1,es2] = dosubset d es1 [es2]
evalSubset d [es1,es2] = dosubset d [es1] [es2]
evalSubset _ _ = none
\end{code}
The first line above matches the case when both sets are enumerations.
The remainder treat a non-set argument as being a singleton set.
The last line 

\subsection{UTCP Expressions}

We have sets of labels
so we need a way to implement set-expressions.
To avoid long set expressions a number of shorthands are desirable,
so that a singleton set $\setof x$ is rendered as $x$
and the very common idiom $S \subseteq ls$
is rendered as $ls(S)$,
so that for example, $ls(in)$ is short for $\setof{in} \subseteq ls$.
So we encode a set construct as follows:
\begin{code}
set = App "set"                             -- set constructor
showSet d [elm] = edshow d elm      -- drop {,} from singleton
showSet d elms = "{" ++ dlshow d "," elms ++ "}"
\end{code}
We also define an equality tester for sets,
that gets the two element-lists

The predicate \texttt{isGround} checks to see if an expression has no
dynamic variables.
For the purposes of this theory at least,
we know we can treat these expressions as values.
This is a common feature of encoding theories for this calculator%
---%
knowing when a particular simplification makes sense.
The dictionary entry for the set construct then looks like
\begin{code}
ExprEntry ["*"] showSet none eqSet
\end{code}
where we permit any substitutions directly on the elements,
and we use the special builtin function \texttt{none}
as an evaluator that does not make any changes,
since we regard these sets as evaluated, in this theory.

Similar tricks are used to code a very compact rendering
of a mechanism that involves unique label generators
that can also be split, so that an expression like
\[
 \pi_2(new(\pi_1(new(\pi_1(split(\pi_1(new(g))))))))
\]
can be displayed as $\ell_{g:1:}$, or,
within the calculator, as \texttt{lg:1:} .


\subsubsection{Expression Entries}~

\begin{verbatim}
Entry s
  = ExprEntry
    { ecansub :: [String]
    , eprint :: Dict s -> [Expr s] -> String
    , eval :: Dict s -> [Expr s] -> (String, Expr s)
    , isEqual :: Dict s -> [Expr s] -> [Expr s] -> Maybe Bool}
  | ...
\end{verbatim}
Imagine that \texttt{App name args }is being processed
and that a dictionary lookup with key \texttt{name}
has returned an expression entry.
The entry contains four pieces of information:
\begin{description}
  \item[\texttt{ecansub}]
     is a list of variable names,
      over which it is safe to perform substitutions.
  \item[\texttt{eprint}]
    is a function that takes a dictionary as first argument,
    the argument-list \texttt{args} as its second argument
    and returns a string rendering of the expression.
    Currently we view expressions as atomic one-line texts
    for output purposes.
  \item[\texttt{eval}]
    takes similar arguments to \texttt{eprint},
    but returns a string/expression pair,
    that denotes a possible evaluation or simplification
    of the original expression.
    The string is empty if no change occurred,
    otherwise it is a short description of/name for the eval/simplify step.
  \item[\texttt{isEqual}]
    has a dictionary argument, followed by two sub-expression lists.
    it tests for (in)equality, returning \texttt{Just True} or \texttt{Just False}
    if it can establish (in)equality,
    and \texttt{Nothing} if unable to give a definitive answer.
\end{description}
The dictionary argument supplied to the three functions
is always the same as the dictionary in which the entry was found.

To understand the need for \texttt{ecansub},
consider the following shorthand definition for an expression:
\[
  D(L) \defs L \subseteq ls
\]
in a context where we know that $L$ is a set expression defined
only over variables $g$, $in$ and $out$.
Now, consider the following instance, with a substitution,
and two attempts to calculate a full expansion:
\[\begin{array}{l@{\qquad}l}
   D(\setof{out})[\setof{\ell_1},\ell_2/ls,out]
 & D(\setof{out})[\setof{\ell_1},\ell_2/ls,out]
\\ {} = (\setof{out} \subseteq ls)[\setof{\ell_1},\ell_2/ls,out]
 & {}= D(\setof{\ell_2})
\\ {} = \setof{\ell_2} \subseteq \setof{\ell_1}
 & {} = \setof{\ell_2} \subseteq ls
\end{array}\]
The lefthand calculation is correct, the righthand is not.
The substitution refers to variables (e.g. $ls$)
that are hidden when the $D$ shorthand is used.
The \texttt{ecansub} entry lists the variables for which substitution
is safe with the expression as-is.
With the definition above, the value of this entry
 should be \texttt{["g","in","out"]}.
Given that entry, the calculator would simplify (correctly) as follows:
\[
  D(\setof{\ell_2})[\setof{\ell_1}/ls]
\]
The righthand side of the definition is what should be returned
by the \texttt{eval} component.
If we want to state that any substitution is safe,
then we use the ``wildcard'' form: \texttt{["*"]}.

\DRAFT{Put this somewhere useful: One big win in using a functional language like Haskell,
in which functions are first class data values,
is that we can easily define datatypes that
contain function-valued components.
We make full use of this in three of the entry kinds discussed below.
}

