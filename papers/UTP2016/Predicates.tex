\section{Predicates}\label{sec:Predicates}

In Fig. \ref{fig:pred-types} we show the Haskell declarations
of the datatypes to represent predicates.
\begin{figure}[tb]
\begin{verbatim}
data Pred s
  = T | F | PVar String | Equal (Expr s) (Expr s) | Atm (Expr s)
  | Comp String [MPred s] | PSub (MPred s) (Substn s) | PUndef

type MPred s = (Marks, Pred s)
\end{verbatim}
  \caption{Predicate Datatypes (\texttt{CalcTypes.lhs})}
  \label{fig:pred-types}
\end{figure}
We have two mutually recursive types,
with \texttt{Pred} giving the basic structure,
while \texttt{MPred} bundles a \texttt{Pred} 
with a \texttt{Marks} datatype.
All references from a \texttt{Pred} to a sub-component invoke
the \texttt{MPred} form.
At the top-level we use an \texttt{MPred} to represent a complete predicate.
In effect this allows any part of a predicate to be marked
in order to facilitate better transcript production,
mainly to provide a way to highlight modified parts
around each step.
This marking is managed under the hood,
and the only impact on the user of the calculator
is the need to be aware of the mutual recursion
when writing patterns.

Similar to expressions we have basic values such as true (\texttt{T})
and false (\texttt{F}),
 with predicate-valued variables (\texttt{PVar}),
and composite predicates (\texttt{Comp}) which are the predicate equivalent
of \texttt{App} (see Sect. \ref{sec:Expressions}).
We also have two ways to turn expressions into predicates.
One (\texttt{Atm}) lifts an expression, which should be boolean-valued
into an (atomic) predicate,
while the other is an explicit representation (\texttt{Equal})
for expression equality.
We can also substitute over predicates (\texttt{PSub})
and we have an undefined predicate (\texttt{PUndef}).

In many ways,
we define our predicates of interest
in much the same was as done for expressions.
Basic logic features such as negation, conjunction, etc.,
are not built in,
but have to be implemented using \texttt{Comp}.
A collection of these are pre-defined as part of the calculator,
in the Haskell module \texttt{StdPredicates}.

There are a few ways in which the treatment of predicates
differ from expressions:
\begin{itemize}
  \item
    The simplifier and some of the infrastructure for handling
    laws treats \texttt{PVar} in a special way.
    It is possible to associate an \texttt{AlfEntry} in the dictionary
    with a \texttt{PVar}, so defining its alphabet.
    This can be useful when reasoning about atomic state-change
    actions which only depend on $s$ and $s'$.
    Such entries will be looked up when certain 
    side-conditions are being checked.
  \item
    We distinguish between have a definition associated with a \texttt{Comp},
    and having a way to simplify one.
  \item 
    Rendering predicates involves the pretty printer
    so the interface is more complex.
    We explain this below.
\end{itemize}



\subsection{Coding Atomic Semantics}

Formally, using our shorthand notations, we define atomic behaviour as:
\[
    \A(A) \defs ls(in) \land A \land ls'=ls\ominus(in,out)
\]
where $A$ is a predicate whose alphabet is restricted to $s$ and $s'$.

We want to define a composite, called "A" (representing $\A$),
as a marked predicate.
We make use of a built-in function that builds
a marked composite, with a null marking
\begin{verbatim}
comp :: String -> [MPred s] -> MPred s
\end{verbatim}
We then define a function that takes a single predicate argument
and applies $\A$ to it
\begin{code}
patm mpr = comp "A" [mpr] -- we assume mpr has only s, s' free
\end{code}
We can now code up its definition,
which takes a dictionary, and a list of its subcomponents
and returns a string/predicate pair,
interpreted in the same manner as the string/expression pair
returned by the expression simplifier.

We code this up as follows:
\begin{code}
defnAtomic d [a] = ("A",mkAnd [lsin,a,ls'eqlsinout])
-- globally defined useful fragments:
ls = Var "ls"
inp = Var "in" -- 'in' is a Haskell keyword
out = Var "out"
lsin = atm $ App "subset" [inp,ls]
lsinout = App "sswap" [ls,inp,out]
ls'eqlsinout = equal ls' lsinout
\end{code}
Here \texttt{equal} is to \texttt{Equal} as \texttt{comp} is to \texttt{Comp}: 
it produces an \texttt{MPred} with a null marking.
The function \texttt{mkAnd} is a smart builder from \texttt{StdPredicates}
that does some optimisations on the fly (e.g. \verb$mkAnd [mpr] = mpr$).
Here \texttt{"sswap"} names the ternary operation $\_\ominus(\_,\_)$.

The rendering of \texttt{App} expressions used a dictionary and list of its
sub-expressions to produce a string.
For Comp predicates, we are going to generate an instance
of the pretty-printer type \texttt{PP}, using a dictionary
and list of sub-predicates,
with two additonal arguments:
one of type \texttt{MarkStyle} which describes how markings should be rendered,
and one of type \texttt{Int} which gives a precedence level.
The type signature is
\begin{verbatim}
Dict s -> MarkStyle -> Int -> [MPred s] -> PP
\end{verbatim}
As far as user-written rendering code is concerned,
the \texttt{MarkStyle} argument is simply passed into any pretty-printing
function that needs it---its handling is done in the pretty-printing
infrastructure.
The most useful and such function is \texttt{mshowp} of type
\begin{verbatim}
(Ord s, Show s) => Dict s -> MarkStyle -> Int -> MPred s -> PP
\end{verbatim}
It prettyprints its \texttt{MPred} argument, using dictionary lookups
to find user defined code.
Such code, for example, would be like the following code
to render our atomic construct:
\begin{code}
ppPAtm d ms p [mpr]
 = pplist [ ppa "A"
          , ppbracket "(" (mshowp d ms 0 mpr) ")"]
\end{code}
The functions \texttt{pplist}, \texttt{ppa} and \texttt{ppbracket}
build instances of \texttt{PP} respectively,
that represent lists of \texttt{PP}, 
atomic strings,
and an occurence of \texttt{PP} surrounded by the designated brackets.
Note that the \texttt{MarkStyle} argument (\texttt{ms}) 
is just passed into \texttt{mshowp},
and the precedence is set to zero as it is bracketed.



We will show how the pretty-printing for
sequential composition  ($\lseq$) in UTCP is defined,
just to show how easy support for infix notation is.
\begin{code}
ppPSeq d ms p [mpr1,mpr2]
 = paren p precPSeq -- parenthesise if precedence requires it
     $ ppopen  (pad ";;") [ mshowp d ms precPSeq mpr1
                          , mshowp d ms precPSeq mpr2 ]
\end{code}
Here \texttt{pad} puts spaces around its argument,
and so is equivalent to \verb$ppa " ;; "$,
while \texttt{ppopen} uses its first argument as a
separator between all the elements of its second list argument.
The \texttt{paren} function takes two precedence values,
and a \texttt{PP} value, and puts parentheses around it if the first precedence
number is greater than the second.
The variable \texttt{precPSeq} is the precedence level of sequential composition,
here defined to be tighter than disjunction,
but looser than conjunction, as defined in module \texttt{StdPrecedences}.

\subsubsection{The Predicate Entry}~

The dictionary entry for predicates has the following form:
\begin{verbatim}
Entry s
  = ...
  | PredEntry
    { pcansub :: [String]
    , pprint :: Dict s -> MarkStyle -> Int -> [MPred s] -> PP
    , alfa :: [String]
    , pdefn :: Rewrite s
    , prsimp :: Rewrite s }
type Rewrite s = Dict s -> [MPred s] -> (String, Pred s)
\end{verbatim}
Fields \texttt{pcansub}, \texttt{pdefn}, 
and \texttt{prsimp} are the predicate analoges
of \texttt{ecansub} and \texttt{eval} in the expression entry.
Here \texttt{pprint} plays the same role as eprint,
but is oriented towards pretty printing.
The \texttt{alfa} component allows an specific alphabet to
be associated with a composite
---if empty then the dictionary alphabet entries apply.

The dictionary entry for our atomic semantics is then:
\begin{code}
patmEntry
 = ( "A"
   , PredEntry [] ppPAtm [] defnAtomic (pNoChg "A") )
\end{code}
The function \texttt{pNoChg} creates a simplifer that does nothing.

