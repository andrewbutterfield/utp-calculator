\section{Introduction}\label{sec:Intro}

We present a calculator \dots

\subsection{Motivation}

The developments of a Unifying Theory of Programming (UTP)
can involve a number of false starts,
as alphabet variables are chosen
and semantics and healthiness conditions are defined.
Typically, some calculations done just to check that everything
is fine in fact reveal problems with the theory.
So we iterate by revising the basic definitions,
and attempting the calculations again.
Hopefully, these eventually converge to what becomes a sound and useful
UTP Theory.
In a recent bout of such theory revision and re-calculation,
which required five iterations in total,
the author noted that common patterns of proof-steps kept occurring
in each iteration.

We have recently started to explore using UTP
to do the  formal modelling of a language,
called ``Process Modelling Language'' (PML),
designed to describe software development and similar business
processes \cite{DBLP:journals/infsof/AtkinsonWN07}.
The main objective is to give PML a formal semantics,
as the basis for a number of analysis tools that could be made available
to process designers and users---with one key application
area being the modelling of clinical healthcare pathways.
It quickly became apparent that PML and similar (business) process
notations essentially involve concurrency with global shared mutable state.

There has been work using UTP
to model concurrent programs with shared mutable state,
most notably
with an encoding into action systems having been done by
Woodcock and Hughes\cite{DBLP:conf/icfem/WoodcockH02}.
We have been looking at adapting this work to provide a UTP semantics
for PML.
%In addition, we have started to take an interest in the ``Views'' paper
%by Dinsdale-Young and colleagues\cite{conf/popl/Dinsdale-YoungBGPY13},
%that provides a framework within which it is possible
%to construct instances of many different concurrency theories,
%ranging from
%type-theory \cite{tal-toplas,Smit00b,journals/fuin/AhmedFM07},
%Owicki-Gries\cite{Owicki76},
%separation logic\cite{conf/lics/CalcagnoOY07}
%and rely-guarantee\cite{Jones83}
%approaches,
%among others.

So we started by taking the action-system UTP semantics for Unifying Theories
of Parallel Programming (UTPP) \cite{DBLP:conf/icfem/WoodcockH02},
and reworking it to use a system for generating unique labels,
in order to give a slight improvement to the compositionality
of the semantics. This we call a Unifying Theory of Concurrent Programming
(UTCP) and details of this are,
at the time of writing,
accepted for publication\cite{conf/tase/BMN16}.
We give a very brief overview here of this theory.
The language assumes atomic actions ($A$) that modify a generic state,
and four composition operators: sequential ($\lseq$), parallel ($\parallel$),
non-deterministic choice ($\pcond$) and non-deterministic iterations ($\piter{}$)
\[
   P ::= A \mid P \pseq P \mid P \parallel P \mid P \pcond P \mid \piter P
\]
Note that this is essentially the same as the baseline ``Command'' language
in the Views paper\cite{conf/popl/Dinsdale-YoungBGPY13}.
In UTCP we have two distinct groups of observations:
\begin{itemize}
  \item
    Variables that track changes during execution
    (dynamic observations),
    modelling the generic state ($s,s'$)
    and the global label-set ($ls,ls'$) used to manage control-flow.
  \item
    Variables that record static parameters such as start ($in$)
    and stop ($out$) labels for a construct,
    as well as a label generator ($g$) associated with each construct.
\end{itemize}
So our UTCP theory is based on a non-homogeneous relation
with alphabet $s$, $s'$, $ls$, $ls'$, $g$, $in$, and $out$.


The theory with its somewhat unusual arrangement of observation variables
did \emph{not} emerge as an immediate and obvious solution.
The theory design started with an homogeneous alphabet with $g'$, $in'$ and $out'$
being present.
Semantic definitions were proposed for all constructs,
and then a series of calculations were undertaken in order to check
the validity of those definitions.
The first such calculation was that of the semantics of a single atomic
action ($A$), and this always seemed to work out fine.
The second calculation was of the sequential composition of two atomic
actions ($A\pseq B$), and this is where problems arose.

The first problem was relatively minor
---a lot of the semantics talks about the presence of various
labels in the global label-set, or alternatively, their  absence,
and of modifications to that set.
This resulted in very wide expressions,
so some shorthand notations were introduced:
using $\ell$ to denote singleton set $\setof\ell$;
or writing $ls(L)$ instead of $L \subseteq ls$, for example.

The second problem was more serious.
The calculation to take $A \pseq B$,
expand it using the semantics of $\pseq$,
and reduce it down to a simple predicate that described the fairly obvious
correct behaviour,
was very lengthy.
Often it would give the right result,
but then checking $A \parallel B$ (an even longer calculation)
would give an incorrect answer.
In every case the fault was traced back to sequential composition%
\footnote{
In the author's experience,
when building semantic theories involving concurrency or parallelism,
it is always sequential composition that causes the most difficulty
}
,
where either the definition of $\pseq$ was wrong,
or, as proved crucial,
the behaviour of ``standard'' UTP sequential composition
was at fault.
The calculations for sequential and parallel composition
required typically about 400 lines of \LaTeX\ and resulted
in 7 full pages of output,
an extract of which is shown in Fig. \ref{fig:attempt4}.

\begin{figure}
  \centering
  \includegraphics[width=4.5in]{Attempt4.eps}\\
  \caption{Extract from 4th attempt to calculate $x:=x+y \parallel y:=y-x$}
  \label{fig:attempt4}
\end{figure}

With choice and iteration to be covered,
it was becoming very clear that a better way was required
for checking semantic outcomes.


\subsection{Structure of this paper}
