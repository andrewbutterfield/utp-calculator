\section{Building Theories}\label{sec:Theorising}

%Sometimes learning by doing is the best approach,
%so here we sketch out how a theory like UTCP
%is captured in way that this calculator
%can be usefully used to perform validating calculations.

We now present extracts from a theory built using this
approach to illustrate how the calculator is used.
As already stated,
the user of this calculator does require some expertise
in functional programming with languages that support
pattern-matching (e.g. Haskell, ML).
We do this by giving an overview of the Haskell encoding
of the UTCP theory
that was the motivation for this work.
The emphasis here is on how to encode a UTP theory for use with this
calculator,
rather than trying to explain the theory itself, or its design motivation

\input{UTCP-in-Haskell}

\subsection*{Paper Plan - 20 page limit}

\begin{itemize}
  \item
     Present a development of a theory using the calculator,
     step by step.(\S\ref{sec:Theorising})
\end{itemize}

Show how the $ls(L)$ shorthand gets encoded,
and a predicate definition.

See also \texttt{CalcAlphabets.lhs}

\subsection{Coding Laws}\label{ssec:coding-laws}

Explain the \texttt{Rewrite}/\texttt{RWResult} distinction
and give an example of a \texttt{DictRWFun}.

\subsection{No Quantifiers}\label{ssec:no-quant}

    They bring a world of pain with them,
    and as it turns out, are not required
    for the kinds of calculations we wish to do.
    Handwritten proofs of laws involving concepts
    defined using quantifier and binders
    are required to validate the laws,
    but these are easy to do---the pain is automating these proofs,
    not doing them by hand.

    Substitutability

\subsection{No Targetting}\label{ssec:no-target}

First-come, first-served.

\subsection{Dictionary Libraries}

explain how dictionaries are managed and constructed,
and describe the ``builtin'' dictionaries (a.k.a. \texttt{StdXXX})
