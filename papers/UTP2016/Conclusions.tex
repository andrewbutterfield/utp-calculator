\section{Conclusions}\label{sec:Conc}

The calculator was used to develop the semantic definitions
for our UTP theory of concurrent programming (UTCP),
and has proved to be invaluable in checking that all
the definitions led to the correct outcomes.
It continues to be in active use with work in this area
that is extending and improving the theory.

However, there are no guarantees of soundness.
Great care has been taken to ensure that the pre-packaged
dictionaries are correct,
and similar care is needed to ensure that theory-specific
definitions are correct.
But working on a theory by hand faces exactly the same issues
--- a proof or calculation by hand always raises the issue
of the correctness of a law, or the validity of a ``proof-step''
that is really a number of simpler steps all rolled into one.
In either case, by hand or by calculator,
the theory developer has a responsibility to carefully check every line.
This is one reason why so much effort was put into pretty-printing
and marking. 
The calculator's real benefit is the ease with which
it can produce a calculation and transcript.

In effect, this UTP Calculator is a tool that assists
with the validation of UTP semantic definitions,
and is designed for use by someone with expertise
in UTP theory building,
and a good working knowledge of Haskell.

A key lesson learnt during the development
of both the calculator, and the UTCP theory,
is the value of the agile approach.
By focussing development of both on what
was the immediate need at any given moment,
we found that the calculator, and its dictionaries,
were prevented from excessive bloat
e.g., coding up a common, useful, obvious law,
that actually wasn't needed.
What was important was 
finding the ``sweet spot'' between the use of definition
expansion, and hard-coded laws based on by-hand proofs.

A very interesting observation was that most effective use
of the calculator seems to involve defining shorthand 
combinator like notations, and hand-proving key laws
about how they interact with key operators used
in semantics definitions, such as standard UTP sequential composition.
This drives the development of what is a bespoke semantics algebra.


There is very little work similar to this in the literature.
In \cite{Bird14} we find a calculator
for point-free equational proofs as a final case-study.
Also of interest is the discussion of deep/shallow embedding
in \cite{Gibbons:2014:FDS},
which suggests, that although our calculator is based on deep embedding,
the way it uses hand-coded laws from dictionaries
it more like shallow-embedding in character.


\subsection{Future Work}\label{ssec:Future}

We plan a formal release of this calculator as a Haskell package.
A key part of this would be comprehensive
user documentation of the key parts of the calculator API,
the standard built-in dictionaries,
as well as a complete worked example of a theory encoding.
There are many enhancements that are also being considered,
that include better transcript rendering options
(e.g. \LaTeX) or ways to customise the REPL
(e.g. always do a simplify step after any other REPL command).
Also of interest would be finding 
a way of connecting the calculator 
to either the \UTP2 theorem-prover\cite{DBLP:conf/utp/Butterfield10}
or the Isabelle/UPT encoding\cite{DBLP:conf/utp/FosterZW14}
in order to be able to validate the dictionary entries.

