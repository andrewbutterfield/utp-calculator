TYPES :-

type MPred m s = ( [m], Pred m s )

type CalcResult m s = (String, MPred m s)
type CalcStep m s = MPred m s -> CalcResult m s

type CCalcResult m s
 = ( String
   , [( Pred m s    -- condition to be discharged
      , MPred m s)]  -- modified predicate
   )
type CCalcStep m s = MPred m s -> CCalcResult m s

data MPred' m s
 = Comp'         -- parent is a Comp node
     [m]         -- parent marking
     String      -- parent name
     [MPred m s] -- components before current focus
     [MPred m s] -- components after current focus
 | PSub'         -- parent is a PSub node
     [m]         -- parent marking
     (Substn s)  -- substitution in parent

type MPZipper m s
  = ( MPred m s    -- the current (focus) predicate
    , [MPred' m s] -- the steps we took to get here,
                   -- and what we passed on the way.
    )

SIMPLIFY :-

simplify
 :: (Mark m, Ord s, Show s)
 => Dict m s
 -> m
 -> CalcStep m s

STEPS :-

type BeforeAfter m s
 = ( MPred m s   -- before predicate, marked
   , String      -- justification, null if no change occurred
   , MPred m s ) -- after predicate, marked

type MPZip2 m s = (BeforeAfter m s, [MPred' m s])

type CMPZip2 m s =
  (MPred m s, String, [(Pred m s, MPred m s)], [MPred' m s])

doAtomicStep ::
  Mark m =>
  m
  -> (m -> CalcStep m s)
  -> MPred m s
  -> Maybe (MPred m s, String, MPred m s)

doStepSearch ::
  Mark m =>
  m
  -> CalcStep m s
  -> MPred m s
  -> Maybe (MPred m s, String, MPred m s)

stepFocus :: CalcStep m s -> MPZipper m s -> MPZip2 m s

stepComponents :: CalcStep m s -> MPZipper m s -> MPZip2 m s


stepCFocus :: CCalcStep m s -> MPZipper m s -> CMPZip2 m s

stepCComponents :: CCalcStep m s -> MPZipper m s -> CMPZip2 m s

RUN :-

calcREPL ::
  (Mark m, Show m, Ord s, Show s) =>
  Dict m s -> MPred m s -> IO (MPred m s, [CalcResult m s], Dict m s)

runREPL ::
  (Mark m, Show m, Ord s, Show s) =>
  Dict m s
  -> m
  -> (MPred m s, [CalcResult m s])
  -> MPred m s
  -> IO (MPred m s, [CalcResult m s], Dict m s)

calcUndo ::
  (Mark m, Show s, Show m, Ord s) =>
  Dict m s
  -> m
  -> (MPred m s, [CalcResult m s])
  -> MPred m s
  -> IO (MPred m s, [CalcResult m s], Dict m s)

calcHelp ::
  (Mark m, Show s, Show m, Ord s) =>
  Dict m s
  -> m
  -> (MPred m s, [CalcResult m s])
  -> MPred m s
  -> IO (MPred m s, [CalcResult m s], Dict m s)

calcStep ::
  (Mark m, Show m, Ord s, Show s) =>
  Dict m s
  -> m
  -> CalcStep m s
  -> (MPred m s, [CalcResult m s])
  -> MPred m s
  -> IO (MPred m s, [CalcResult m s], Dict m s)
