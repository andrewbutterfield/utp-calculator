\HDRa{Math support for Views}\label{ha:mViews}

We go for a new formulation
\RLEQNS{
   atm(a) &=& \true * (\Skip \lor (in\arr a out) \land [in|out|g])
\\ C &=& \bigvee_{i=0}^\infty (actions(C)) \land [in|out|g] \land I_C
}
where $I_C$ is some more $C$-specific invariants.

\HDRb{Basic Actions}

We define the basic action as:
\RLEQNS{
   E \arr a N
   &\defs&
   ls(E) \land s' \in \sem a s \land ls' = (ls\setminus E)\cup N
}
and calculate its self-sequential composition as:
\RLEQNS{
  && E_1 \arr a N_1 \seq E_2 \arr b N_2
\EQ{Defns of $\seq$ and $\arr{-}$}
\\&& \exists s_m,ls_m @
\\&& \quad ls(E_1) \land s_m \in \sem a s \land ls_m = (ls\setminus E_1)\cup N_1
     \land {}
\\&& \quad ls_m(E_2) \land s' \in \sem b s_m \land ls' = (ls_m\setminus E_2)\cup N_2
\EQ{1pt-rule, $ls_m = (ls\setminus E_1)\cup N_1$}
\\&& \exists s_m @
\\&& \quad ls(E_1) \land s_m \in \sem a s \land s' \in \sem b s_m \land  {}
\\&& \quad ((ls\setminus E_1)\cup N_1)(E_2)
           \land ls' = (((ls\setminus E_1)\cup N_1)\setminus E_2)\cup N_2
\EQ{push scope in}
\\&& ls(E_1) \land
     (\exists s_m @ s_m \in \sem a s \land s' \in \sem b s_m) \land  {}
\\&& ((ls\setminus E_1)\cup N_1)(E_2) \land
     ls' = (((ls\setminus E_1)\cup N_1)\setminus E_2)\cup N_2
\EQ{Defn $\seq$, re-arrange}
\\&& ls(E_1) \land
     ((ls\setminus E_1)\cup N_1)(E_2) \land {}
\\&& s' \in \sem{a\seq b} s) \land
     ls' = (((ls\setminus E_1)\cup N_1)\setminus E_2)\cup N_2
\EQ{simplify $ls'$}
\\&& ls(E_1) \land
     ((ls\setminus E_1)\cup N_1)(E_2) \land {}
\\&& s' \in \sem{a\seq b} s) \land
     ls' = (ls\setminus (E_1\setminus N_1)\cup E_2))
           \cup (N_1\setminus E_2 \cup N_2
\EQ{GUESS $ls$}
\\&& ls(E_1 \cup (E_2 \setminus N_1))\land 
     s' \in \sem{a\seq b} s) \land {}
\\&& ls' = (ls\setminus (E_1\setminus N_1\cup E_2))
           \cup (N_1\setminus E_2 \cup N_2
\EQ{fold defn $\arr{-}$}
\\&& (~E_1 \cup (E_2 \setminus N_1)
     \arr{a\seq b}
     (N_1\setminus E_2) \cup N_2~)
}

Check $(E \arr a N)^2$
\RLEQNS{
  && (E \arr a N)^2
\EQ{prev. calc.}
}

\newpage
\HDRb{Working with the Invariant}

We have introduced the following notation:
\[
  [ L_1 | L_2 | \dots | L_n ]
\]
Its first intended meaning is to assert that
all the $L_i$ are mutually disjoint:
\RLEQNS{
   \forall i,j \in 1\dots n @ i \neq j \implies L_i \cap L_j = \emptyset
}
It also states that if any one of its members overlaps with $ls$,
then none of the others do (and similarly for $ls'$):
\RLEQNS{
  &&   \forall i,j \in 1\dots n @
        i \neq j \land L_i \cap ls \neq \emptyset
        \implies L_j \cap ls = \emptyset
\\&&   \forall i,j \in 1\dots n @
        i \neq j \land L_i \cap ls' \neq \emptyset
        \implies L_j \cap ls' = \emptyset
}

By \emph{design}, our labels and generator scheme
establishes the following (weakest) invariant:
\[ [in|out|g]\]
and for any generator expression $G$ we can split it into
four disjoint parts (also by design) to get
\[  [\ell_G|G_{:}|G_1|G_2] . \]
So we can always strengthen out invariant by splitting some $G$
in this way:
\RLEQNS{
  && [in|out|g]
\EQ{split $g$}
\\&& [in|out|\ell_g|\g:|\g1|\g2]
\EQ{split $\g:$}
\\&& [in|out|\ell_g| \ell_{g:}|\g{::}|\g{:1}|\g{:2}|\g1|\g2]
}
However, sometimes we don't wait to do this.
The hope is that by requiring $[in|out|g]$ at each level,
that we get the right level of exclusivity vs. sharing of $ls$
by generated labels.

\newpage
\HDRb{Semantic Definitions}

For ``wheels-within-wheels'' to work,
we need to ensure we spin up as long as any constituent
atomic action does not have its $out$ label in $ls$.
\RLEQNS{
  C &=& ls(\B{OUT}) * \bigvee_{i=1}^n in_i \arr{a_i} out_i
\\ && \textbf{where }OUT = \setof{out_1,\dots,out_n}
}
Now this looks a little non-compositional,
but perhaps we can get this outcome by only looking one level down\dots

We assume the generator invariant $[in|out|g]$
and all its strengthening hold throughout.



\RLEQNS{
   E \arr a N &\defs& ls(E) \land s'\in\sem a \land ls'=(ls\setminus E)\cup N
\\ atm(a) &\defs& ls(\B{out}) * in \arr a out
\\ C \cseq D
   &\defs&
   ls(\B{\ell_g,out}) *
     ( C[\ell_g,\g{:1}/out,g] \lor
       D[\ell_g,\g{:2}/in,g] )
\\ C + D
   &\defs&
   ls(\B{out}) *
     ( C[g_{1:},\ell_{g1}/g,in] \lor
       D[g_{2:},\ell_{g2}/g,in] )
\\ C \parallel D
   &\defs&
   ls(\B{\ell_{g1},\ell_{g2},\ell_{g1:},\ell_{g2:},out}) * {}
\\&& \quad (~
      (in \arr{ii} \ell_{g1},\ell{g2}) \lor
      (\ell_{g1:},\ell{g2:} \arr{ii} out) \lor {}
\\&& \quad ~~
       C[g_{1::},\ell_{g1},\ell_{g1:}/g,in,out] \lor
       D[g_{2::},\ell_{g2},\ell_{g2:}/g,in,out] ~)
\\ C^*
   &\defs&
   ls(\B{out}) *
     (~ (in \arr{ii} out) \lor
       (in \arr{ii} \ell_g) \lor
       C[\g:,\ell_g,in/g,in,out] ~)
}


\newpage
\HDRb{Semantic Calculations}

We need to only investigate the combinators
applied to atoms, but also some nesting to see if everything
does keep going.

The basic principle relies on the following properties of
standard UTP iteration:
\RLEQNS{
  && c*P
\EQ{loop unroll}
\\&& P \seq c*P \cond c \Skip
\EQ{defn. of $\cond{}$}
\\&& \lnot c \land \Skip
     \lor
     c \land (P \seq c*P)
\EQ{push $c$ into $\seq$}
\\&& \lnot c \land \Skip
     \lor
     c \land P \seq c*P
\EQ{repeat above steps several times with $\lor$-$\seq$-distr.}
\\&& \lnot c \land \Skip
     \lor
     c \land P \seq \lnot c \land \Skip
     \lor
     (c \land P)^2 \seq \lnot c \land \Skip
     \lor \dots \lor
     (c \land P)^n \seq c*P
\EQ{pushed to the limit}
\\&& \bigvee_{i=0}^\infty (c \land P)^i \seq \lnot c \land \Skip
}

We introduce further shorthand:
\RLEQNS{
   D &\defs& \lnot c \land \Skip
\\ S &\defs& c \land P
\\ c*P &=& \bigvee_{i=0}^\infty S^i \seq D
}
So the nature of $S^i\seq D$ is the critical thing to compute.


SOME OLD STUFF THAT MAY NEED REWRITING:

Now, for our basic primitives some easy calculations show:
\RLEQNS{
   D(T) &\implies& ls(T) \land ls'(T)
\\ E \arr a N &\implies& ls(E) \land ls'(N)
}
If we keep in mind that,
\RLEQNS{
  P \land c' \seq Q &=& P \seq c \land Q
}
then we can very easily read-off whether or not sequential compositions
of these two violate the invariant, e.g, given $[in|out|\ell_g]$
\RLEQNS{
   D(in) \seq D(\ell_g) &=& \false
\\ (in \arr a \ell_g) \seq (\ell_g \arr b out)
    &=& (in \arr{a \seq b} out)
\\ (in \arr a \ell_g) \seq (in \arr a \ell_g) &=& \false
\\ (in \arr a \ell_g) \seq D(out) &=& \false
\\ (in \arr a \ell_g) \seq D(\ell_g) &=& (in \arr a \ell_g)
}
