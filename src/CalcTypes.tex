\HDRa{Calculator Types (Listing)}\label{ha:calc-types-txt}

\HDRb{User Types}


\begin{code}
data Expr s
 = St s  -- a value of type State
 | B Bool
 | Z Int
 | Var String
 | App String [Expr s]
 | Sub (Expr s) (Substn s)
 | Undef
 deriving (Eq,Ord,Show)

type Substn s = [(String,Expr s)]
\end{code}

\begin{code}
data Pred s
 = T
 | F
 | PVar String
 | Equal (Expr s) (Expr s)
 | Atm (Expr s)
 | Comp String [Pred s]
 | PSub (Pred s) (Substn s)
 deriving (Eq, Ord, Show)
\end{code}
\begin{code}
type RWResult s
 = Maybe ( String  -- rewrite justification
         , Pred s  -- result predicate
         , Bool )  -- True if top-level modified
type RWFun s = Dict s -> Pred s -> RWResult s
\end{code}

\begin{code}
type CRWResult s
 = Maybe ( String      -- justification
         , [( Pred s   -- side-condition to be discharged
            , Pred s   -- modified predicate
            , Bool)])  -- True if top-level modified
type CRWFun s = Dict s -> Pred s -> CRWResult s
\end{code}

\newpage
\begin{code}
type Dict s = M.Map String (Entry s)
\end{code}

\begin{code}
type Rewrite s = Dict s -> [Pred s] -> RWResult s
\end{code}

\begin{code}
type SubCompPrint s = Int -> Pred s -> PP
\end{code}

\begin{code}
data Entry s =
   AlfEntry {   -- about Alphabets
    avars   :: [String]  -- alphabet
   }
 | ExprEntry { -- about Expressions
     ecansub :: [String]                   -- substitutable vars
   , eprint  :: Dict s -> [Expr s] -> String   -- pretty printer
   , eval    :: Dict s -> [Expr s]                  -- evaluator
             -> ( String -- empty if no change, else explanation
                , Expr s )
   , isEqual :: Dict s -> [Expr s] -> [Expr s] -> Maybe Bool
   }
 | PredEntry {    -- about Predicates and PredVars
     pcansub :: [String]                   -- substitutable vars
   , pprint  :: SubCompPrint s                 -- pretty-printer
             -> Dict s -> Int -> [Pred s]
             -> PP
   , alfa :: [String]                      -- predicate alphabet
   , pdefn   :: Rewrite s                      -- defn expansion
   , prsimp  :: Rewrite s                          -- simplifier
   }
 | LawEntry {  -- about useful laws
     reduce  :: [RWFun s]            -- reduction laws
   , creduce :: [CRWFun s]           -- conditional reductions
   , unroll  :: [String -> RWFun s]  -- loop unrollers
   }
\end{code}

\begin{code}
type Recogniser s = Pred s -> Maybe [Pred s]
\end{code}


\newpage
\HDRb{System Types}


\begin{code}
type Mark = Int
type Marks = [Mark]
\end{code}

\begin{code}
data MTree = MT Marks [MTree] deriving (Eq, Ord, Show)
\end{code}

\begin{code}
type MPred s = ( Pred s, MTree )
\end{code}

\begin{code}
type MarkStyle = Int -> Maybe Style
\end{code}

\begin{code}
data Pred' s
 = Comp'        -- parent is a Comp node
     String       -- parent name
     [Pred s]     -- components before current focus
     [Pred s]     -- components after current focus
 | PSub'        -- parent is a PSub node
     (Substn s)   -- substitution in parent
 deriving Show

data MTree'
 = MT'       -- parent is always a MT node
     Marks     -- parents marking
     [MTree]   -- components before current focus
     [MTree]   -- components before current focus

type MPred' s = ( Pred' s, MTree' )

type MPZipper s
  = ( MPred s    -- the current (focus) predicate
    , [MPred' s] -- the steps we took to get here,
                   -- and what we passed on the way.
    )
\end{code}

\newpage
\begin{code}
type MRWResult s
 = Maybe ( String  -- rewrite justification
         , MPred s  -- result marked predicate
         , Bool )  -- True if top-level modified

type MCRWResult s
 = Maybe ( String      -- justification
         , [( Pred s   -- side-condition to be discharged
            , MPred s   -- modified marked predicate
            , Bool)])  -- True if top-level modified
\end{code}


\begin{code}
type BeforeAfter s
 = ( MPred s   -- before predicate, marked
   , String      -- justification
   , MPred s ) -- after predicate, marked
\end{code}

\begin{code}
type BeforeAfters s
 = ( MPred s   -- before predicate, marked
   , String      -- justification
   , [(Pred s,MPred s)] ) -- after predicates, marked
\end{code}

\begin{code}
type MPZip2 s = (BeforeAfter s, [MPred' s])
\end{code}

\begin{code}
type CMPZip2 s = ( BeforeAfters s, [MPred' s] )
\end{code}

\begin{code}
type CalcLog s = ( MPred s      -- initial predicate (pe1)
                 , [(String, MPred s)] -- steps, most recent first
                 , Dict s )     -- final dictionary
\end{code}
