\HDRa{Calculator Types (Listing)}\label{ha:calc-types-txt}

\HDRb{User Types}


\begin{code}
data Expr
 = St  -- a value of type State
 | B Bool
 | Z Int
 | Var String
 | App String [Expr]
 | Sub Expr Substn
 | Undef
 deriving (Eq,Ord,Show)

type Substn = [(String,Expr)]
\end{code}

\begin{code}
data Pred
 = T
 | F
 | PVar String
 | Equal Expr Expr
 | Atm Expr
 | Comp String [Pred]
 | PSub Pred Substn
 deriving (Eq, Ord, Show)
\end{code}
\begin{code}
type RWResult
 = Maybe ( String  -- rewrite justification
         , Pred  -- result predicate
         , Bool )  -- True if top-level modified
type RWFun = Dict     -- dictionary
            -> Pred     -- invariant predicate
            -> Pred     -- target predicate
            -> RWResult
\end{code}

\begin{code}
type CRWResult
 = Maybe ( String      -- justification
         , [( Pred   -- side-condition to be discharged
            , Pred   -- modified predicate
            , Bool)])  -- True if top-level modified
type CRWFun = Dict -> Pred -> CRWResult
\end{code}

\newpage
\begin{code}
type Dict = M.Map String (Entry)
\end{code}

\begin{code}
type Rewrite = Dict -> [Pred] -> RWResult
\end{code}

\begin{code}
type SubCompPrint
 = Int       -- precedence level forub-component
   -> Int    -- sub-component number
   -> Pred -- sub-component
   -> PP
\end{code}

\begin{code}
data Entry =
   AlfEntry {   -- about Alphabets
    avars   :: [String]  -- alphabet
   }
 | ExprEntry { -- about Expressions
     ecansub :: [String]                   -- substitutable vars
   , eprint  :: Dict -> [Expr] -> String   -- pretty printer
   , defn    :: Dict -> [Expr]             -- defn expansion
             -> Maybe (String, Expr)
   , simp    :: Dict -> [Expr]                 -- simplifier
             -> ( String -- empty if no change, else explanation
                , Expr )
   , isEqual :: Dict -> [Expr] -> [Expr] -> Maybe Bool
   }
 | PredEntry {    -- about Predicates and PredVars
     pcansub :: [String]                   -- substitutable vars
   , pprint  :: SubCompPrint                 -- pretty-printer
             -> Dict -> Int -> [Pred]
             -> PP
   , alfa :: [String]                      -- predicate alphabet
   , pdefn   :: Rewrite                      -- defn expansion
   , prsimp  :: Rewrite                          -- simplifier
   }
 | LawEntry {  -- about useful laws
     reduce  :: [RWFun]            -- reduction laws
   , creduce :: [CRWFun]           -- conditional reductions
   , unroll  :: [String -> RWFun]  -- loop unrollers
   }
\end{code}

\begin{code}
type Recogniser = Pred -> Maybe [Pred]
\end{code}

\begin{code}
type InvChecker
 = Dict
   -> Pred     -- invariant
   -> Pred     -- test predicate
   -> Maybe Bool
type InvPair
 = ( InvChecker  -- inv check function
   , Pred )      -- invariant predicate
type InvState = [InvPair]
\end{code}

\newpage
\HDRb{System Types}

\begin{code}
type Mark = Int
type Marks = [Mark]
\end{code}

\begin{code}
data MTree = MT Marks [MTree] deriving (Eq, Ord, Show)
\end{code}

\begin{code}
type MPred = ( Pred, MTree )
\end{code}

\begin{code}
type MarkStyle = Int -> Maybe Style
\end{code}

\begin{code}
data Pred'
 = Comp'        -- parent is a Comp node
     String       -- parent name
     [Pred]     -- components before current focus
     [Pred]     -- components after current focus
 | PSub'        -- parent is a PSub node
     Substn   -- substitution in parent
 deriving Show

data MTree'
 = MT'       -- parent is always a MT node
     Marks     -- parents marking
     [MTree]   -- components before current focus
     [MTree]   -- components before current focus

type MPred' = ( Pred', MTree' )

type MPZipper
  = ( MPred    -- the current (focus) predicate
    , [MPred'] -- the steps we took to get here,
                   -- and what we passed on the way.
    )
\end{code}

\newpage
\begin{code}
type MRWResult
 = Maybe ( String  -- rewrite justification
         , MPred  -- result marked predicate
         , Bool )  -- True if top-level modified

type MCRWResult
 = Maybe ( String      -- justification
         , [( Pred   -- side-condition to be discharged
            , MPred   -- modified marked predicate
            , Bool)])  -- True if top-level modified
\end{code}


\begin{code}
type BeforeAfter
 = ( MPred   -- before predicate, marked
   , String      -- justification
   , MPred ) -- after predicate, marked
\end{code}

\begin{code}
type BeforeAfters
 = ( MPred   -- before predicate, marked
   , String      -- justification
   , [(Pred,MPred)] ) -- after predicates, marked
\end{code}

\begin{code}
type MPZip2 = (BeforeAfter, [MPred'])
\end{code}

\begin{code}
type CMPZip2 = ( BeforeAfters, [MPred'] )
\end{code}

\begin{code}
type Step
 = ( String        --tep justification
   , MPred )     -- prev predicate
type State
 = ( MPred       -- current goal predicate
   , [Step]      -- calc steps so far
   , InvState )  -- invariant
type CalcLog = ( State   -- final state
                 , Dict )  -- final dictionary
\end{code}
