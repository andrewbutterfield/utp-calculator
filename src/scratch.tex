\HDRa{scratch}\label{ha:scratch}

{\footnotesize\begin{verbatim}
<a>
 = "defn. of Atom"
W(X(in|out|a|in|out))
 = "W-unroll.1"
D(out) \/ (M(out) /\ X(in|out|a|in|out) ; W(X(in|out|a|in|out)))
 = "M-and-X"
D(out) \/ (X(in|out|a|in|out) ; W(X(in|out|a|in|out)))
 = "W-unroll.1"
    D(out)
 \/ (  X(in|out|a|in|out)
     ; D(out) \/ (M(out) /\ X(in|out|a|in|out) ; W(X(in|out|a|in|out))))
 = ";-or-distr"
    D(out)
 \/     (X(in|out|a|in|out) ; D(out))
     \/ (  X(in|out|a|in|out)
         ; M(out) /\ X(in|out|a|in|out) ; W(X(in|out|a|in|out)))
 = "X-then-D"
    D(out)
 \/     X(in|out|a|in|out) /\ ({} I in) = {}
     \/ (  X(in|out|a|in|out)
         ; M(out) /\ X(in|out|a|in|out) ; W(X(in|out|a|in|out)))
 = "simplify"
    D(out)
 \/     X(in|out|a|in|out)
     \/ (  X(in|out|a|in|out)
         ; M(out) /\ X(in|out|a|in|out) ; W(X(in|out|a|in|out)))
 = ";-left-assoc"
    D(out)
 \/     X(in|out|a|in|out)
     \/ (  X(in|out|a|in|out) ; M(out) /\ X(in|out|a|in|out)
         ; W(X(in|out|a|in|out)))
 = "M-and-X"
    D(out)
 \/     X(in|out|a|in|out)
     \/ (X(in|out|a|in|out) ; X(in|out|a|in|out) ; W(X(in|out|a|in|out)))
 = "X-then-X"
    D(out)
 \/     X(in|out|a|in|out)
     \/ (  X(in|out|a ; a|in|out) /\ (in I in) = {} /\ (out I out) = {}
         ; W(X(in|out|a|in|out)))
 = "simplify"
D(out) \/ X(in|out|a|in|out)
\end{verbatim}}


\newpage
We get these for sequential composition of $atm(a)$ and $atm(b)$.
{\footnotesize\begin{verbatim}
D(lg) ; D(lg)
D(lg) ; X(in|lg|a|in|lg)
D(lg) ; D(out)
D(lg) ; X(lg|out|b|lg|out)
X(in|lg|a|in|lg) ; D(lg)
X(in|lg|a|in|lg) ; X(in|lg|a|in|lg)
X(in|lg|a|in|lg) ; D(out)
X(in|lg|a|in|lg) ; X(lg|out|b|lg|out)
D(out); D(lg)
D(out); X(in|lg|a|in|lg)
D(out); D(out)
D(out); X(lg|out|b|lg|out)
X(lg|out|b|lg|out); D(lg)
X(lg|out|b|lg|out); X(in|lg|a|in|lg)
X(lg|out|b|lg|out); D(out)
X(lg|out|b|lg|out); X(lg|out|b|lg|out)
\end{verbatim}}

Collapse \texttt{D}s, simplify them,
and group similar stuff, with prediction
{\footnotesize\begin{verbatim}
D(lg)
D(out)
D(lg)  ; X(in|lg|a|in|lg)
D(out) ; X(in|lg|a|in|lg)
D(lg)  ; X(lg|out|b|lg|out)
D(out) ; X(lg|out|b|lg|out)
X(in|lg|a|in|lg)   ; D(lg)
X(in|lg|a|in|lg)   ; D(out)
X(lg|out|b|lg|out) ; D(lg)
X(lg|out|b|lg|out) ; D(out)
X(in|lg|a|in|lg)   ; X(in|lg|a|in|lg)
X(in|lg|a|in|lg)   ; X(lg|out|b|lg|out)
X(lg|out|b|lg|out) ; X(in|lg|a|in|lg)
X(lg|out|b|lg|out) ; X(lg|out|b|lg|out)
\end{verbatim}}
use the reduction rules
{\footnotesize\begin{verbatim}
D(lg)
D(out)
D(lg)  ; X(in|lg|a|in|lg) = False,  lg I lg /= {}
D(out) ; X(in|lg|a|in|lg) = X(in,out|lg|a|in|lg)
D(lg)  ; X(lg|out|b|lg|out) = X(lg|out|b|lg|out)
D(out) ; X(lg|out|b|lg|out) = False, out I out /= {}
X(in|lg|a|in|lg)   ; D(lg) = X(in|lg|a|in|lg)
X(in|lg|a|in|lg)   ; D(out) = X(in,out|lg|a|in|lg)
X(lg|out|b|lg|out) ; D(lg) = False lg\out I lg /= {}
X(lg|out|b|lg|out) ; D(out) = X(lg|out|b|lg|out)
X(in|lg|a|in|lg)   ; X(in|lg|a|in|lg) = False, lg I lg /= {}, in\lg I in
X(in|lg|a|in|lg)   ; X(lg|out|b|lg|out) = X(in|lg,out|a;b|in,lg|out)
X(lg|out|b|lg|out) ; X(in|lg|a|in|lg) = X(in,lg|out|b;a|lg,in|out,lg)
X(lg|out|b|lg|out) ; X(lg|out|b|lg|out) = False, out I out /= {}
\end{verbatim}}
Now apply the new $\DLP{}{}{}$ healthiness conditions:
\RLEQNS{
  \DL &=&[in|out|g]& \mbox{top-level}
\\ \DLP{in}{\ell_g}{\g{:1}} &=& [in|\ell_g|\g{:1}]& \mbox{also for }atm(a)
\\ \DLP{\ell_g}{out}{\g{:2}} &=&[\ell_g|out|\g{:2}]& \mbox{also for }atm(b)
\\ ~[in|out|g] \land [in|\ell_g|\g{:1}]
   &=&
   \multicolumn{2}{l}{[in|out|\ell_g|\g{:1}|\g{:2}|\g1|\g2]}
\\ ~[in|out|g] \land [\ell_g|out|\g{:2}]
   &=&
   \multicolumn{2}{l}{[in|out|\ell_g|\g{:2}|\g{:1}|\g1|\g2]}
\\ \DL \land \DLP{in}{\ell_g}{\g{:1}}  &=& [in|out|\ell_g|\g{:1}|\g{:2}|\g1|\g2]&
\\ \DL \land \DLP{\ell_g}{out}{\g{:2}} &=& [in|out|\ell_g|\g{:1}|\g{:2}|\g1|\g2]&
\\ \DL \land \DLP{in}{\ell_g}{\g{:1}} \DLP{\ell_g}{out}{\g{:2}}
    &=& [in|out|\ell_g|\g{:1}|\g{:2}|\g1|\g2]&
}
Here is previous result with False ones removed, and invariant added
{\footnotesize\begin{verbatim}
[in|out|lg|g:1|g:2] D(lg)  -- OK
[in|out|lg|g:1|g:2] D(out)  -- OK
[in|out|lg|g:1|g:2] X(in,out|lg|a|in|lg) -- NOT OK  ls(in,out)
[in|out|lg|g:1|g:2] X(lg|out|b|lg|out) -- OK
[in|out|lg|g:1|g:2] X(in|lg|a|in|lg) -- OK
[in|out|lg|g:1|g:2] X(in,out|lg|a|in|lg) -- NOT OK ls(in,out)
[in|out|lg|g:1|g:2] X(lg|out|b|lg|out) -- OK
[in|out|lg|g:1|g:2] X(in|lg,out|a;b|in,lg|out) -- OK,
[in|out|lg|g:1|g:2] X(in,lg|out|b;a|lg,in|out,lg) -- not OK ls(in,lg)
\end{verbatim}}
We can strengthen the normalise rule
\RLEQNS{
   X(E|D|a|R|A) &=& X(E|D|a|R\setminus(D\cup A)|A)
}
No point removing anything in $D$ because its not there...
So with that simplification we are left with:
{\footnotesize\begin{verbatim}
D(lg)
D(out)
X(lg|out|b|lg|out)
X(in|lg|a|in|lg)
X(in|lg,out|a;b|in|out) -- normalised
\end{verbatim}}
Perfect!
We can also use the invariant to 'normalise' by fleshing out the $D$
component based on the $E$ component.
We can also ask what happens to each $X$ if we do $X;X$
{\footnotesize\begin{verbatim}
X(lg|out|b|lg|out) /\ lg\out I lg = {} /\ out I out = {}
X(in|lg|a|in|lg) /\ in\lg I in = {} /\ lg I lg = {}
X(in|lg,out|a;b|in|out) /\ in\out I in = {} /\ out I out = {}
\end{verbatim}}
They all reduce to false - Yes!

In fact, the invariant makes the $D$ component redundant!.
If $E=\setof{\ell_g}$ (say),
then we can deduce $D = \setof{in,out}\cup labs(\g:)$.

\newpage
{\footnotesize\begin{verbatim}
x
\end{verbatim}}

\newpage
{\footnotesize\begin{verbatim}
x
\end{verbatim}}
